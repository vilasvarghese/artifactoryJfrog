
Reference: https://www.jfrog.com/confluence/display/JFROG/JFrog+Artifactory


#Artifactory Overview
---------------------
JFrog Artifactory 
	Universal DevOps solution providing end-to-end automation and management of 
		binaries and 
		artifacts 
			through the application delivery process 
	Improves productivity across your development ecosystem. 
	Supports 
		25+ software build packages
		all major CI/CD platforms
		various DevOps tools. 
	Artifactory is Kubernetes ready supporting 
		containers, 
		Docker, 
		Helm Charts
	Can be used as Kubernetes and Docker registry 
	Comes with full CLI and REST APIs customizable to your ecosystem.

What is artifactory?
	Place/tool/service to store artifacts
		Can be 
			binary
			git, 
			maven, 
			zip
			war
			exe
			Docker images
				etc.

Why artifactory?
	1. Security of packages
	2. Process driven 
		Generation of artifacts
		Versioning of packages
		CI/CD 
		Traditional package mgmt 
			FTP/Shared drive
			Probably generate 30 packages in a day
			How to name, label, clean etc.
			Generally done using script.
			Artificatory can automatically take care of all these.
	3. Dependency management
		like maven dependency mgmt
		Internal/External dependency
	4. Integrity of the package
		If artifacts are corrupted, quickly validate.
		Inbuilt package integrity check.
			e.g. Checksum md5 check.
	5. Admin
		Create/manage 
			user
			group
			authentication  authorization
	6. Backup and Cleanup efficiently.
		Setup rule to backup/mirroring/cleanup etc.
		

Competitors?
------------
	Sonatype Nexus		Paid
	JFrog Artifactory	Paid
	MS Nuget 			Free
	Apache Archiva		Free
	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	

Main Features and Functionality

	1. Hybrid and Multi-Cloud Environments
		Can be hosted in 
			our own infrastructure
			Cloud 
			SaaS 
				solution providing maximum flexibility and choice. 

	2. Universal Binary Repository Manager
	Offers a universal solution supporting 
		all major package formats including 
			Alpine, 
			Maven, 
			Gradle, 
			Docker, 
			Cargo, 
			Conda, 
			Conan, 
			Debian, 
			Go, 
			Helm, 
			Vagrant, 
			YUM, 
			P2, 
			Ivy, 
			NuGet, 
			PHP, 
			NPM, 
			RubyGems, 
			PyPI, 
			Bower, 
			CocoaPods, 
			GitLFS, 
			Opkg, 
			SBT 

	3. Extensive Metadata
		Provides full metadata for all major package formats for both 
			artifacts and 
			folders. 
		Include metadata 
			originates with the package itself
			custom metadata added by users 
				such as searchable properties 
				metadata that is automatically generated by tools 
					such as build information and more.

	4. Artifactory as Your Kubernetes Registry
	Can deploy containerized microservices to the Kubernetes cluster 
		as it serves as a universal repository manager for all your CI/CD needs, 
		regardless of where they are running in your organization. 
	check in your App package, 
		proceed to propagate and perform the 
			build
			test, 
			promote 
			finally deploy to Kubernetes.

	5. Massively Scalable
	Supports variety of enterprise-scale storage capabilities including 
		S3 Object Storage, 
		Google Cloud Storage, 
		Azure Blob Storage 
		Filestore Sharding 
		providing 
			unlimited scalability, 
			disaster recovery
			unmatched stability
			reliability. 
		Accommodates large load bursts with 
			no compromise to performance. 
		Increase capacity to any degree with horizontal server scalability to serve 
			any number of concurrent users
			build servers and 
			interactions.

	6. Replication
		Supports unique set of replication capabilities 
		Ensure locality in any network topology and for any development methodology. 
		Requirements for distributed pipelines and collaboration can be specific 
			e.g. 
				push and pull replication topologies
				remote/local repositories
				different scheduling strategies such as 
					on-demand, 
					on-schedule 
					event-based replication. For more information, see Replicator.
		Further details: https://www.jfrog.com/confluence/display/JFROG/Replicator
		
	7. High Availability
		Active/active HA solution 
		Live failover 
		Non-disruptive production upgrades. 
		Further details: https://www.jfrog.com/confluence/display/JFROG/High+Availability.

	8. Advanced CI Server integration with Build Tools
		Supports build integration 
			on-prem CI / cloud-based CI / standalone without a CI server. 
		Integration of Artifactory into your build ecosystem 
			provides important information that supports 
				fully reproducible builds 
					through visibility of 
						artifacts deployed, 
						dependencies 
						build environment.

		Provides visibility into your builds 
			through the metadata it attaches to each artifact. 
			For e.g. we can trace container images back to their source
				we always know what’s in your builds. 
		Further details: https://www.jfrog.com/confluence/display/JFROG/Build+Integration
		
	9. Custom API-Driven Automation
		Extensive REST API 
			provides access to its features anywhere in the development cycle. 
		Through the API we can manage 
			builds, 
			repositories 
			artifacts
		can perform 
			searches
			apply configurations
			perform maintenance tasks etc.

	10. Advanced Search with Artifactory Query Language
	AQL (Artifactory Query Language) 
		Flexibility in searching for artifacts. 
		Simple way to formulate complex queries 
			can specify any number of 
				search criteria, 
				filters, 
				sorting options 
				output fields.

	11. Artifactory Cloud with CDN Distribution
	JFrog Artifactory Cloud with Amazon's CloudFront CDN solution 
		allows Enterprise users to 
			manage, 
			control, 
			distribute high volumes of software distribution 
				across multiple locations. 
		The fully integrated advanced CDN solution 
			no separate external CDN Caching system required. 
		Further details: https://www.jfrog.com/confluence/display/JFROG/JFrog+Artifactory+Cloud+with+CDN+Distribution.
	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Understanding a role of Artifactory in DevOps

Pick image from 
	https://www.jfrog.com/confluence/display/JFROG/JFrog+Platform+Overview
	
https://jfrog.com/whitepaper/devops-8-reasons-for-devops-to-use-a-binary-repository-manager/


DevOps must support 
	continual flow of code 
		from the individual developer’s machine 
			to the organization’s production environment. 

Some of the challenges in achieving these are:
	Need stable and reliable access to repositories
	Support for large number of common binaries across different environments
	Security and access control
	Tracing any action done to a file back to the user
	Transferring a large number of binaries to a remote location
	Managing infrastructure configuration across different environments


8 reasons to use a binary repo. manager
	1. System stability and reliability with Artifactory High Availability (HA)
		HIGH AVAILABILITY SYSTEMS
			Systems that are considered mission-critical to an organization 
			Can be deployed in a Highly Availabile configuration to 
				increase stability and reliability. 
				Done by replicating nodes in the system 
				Remove the complete reliability on any single node. 
				Ensure no single-point-of-failure. 
				If any specific node goes down, 
					the system continues to operate 
						seamlessly and 
						transparently 
							to its users through the remaining, redundant nodes 
				No down time or degradation of performance of the system to the end user.

		Artifactory supports a High Availability configuration 
			for a cluster of 2 or more active/ active Artifactory servers 
				on the same Local Area Network.

		Advantages of redundant network architecture:
			No single-point-of-failure
			Accommodate larger load bursts
			Easy maintenace of Multiple server architecture
				
	2. Managing many binaries across different environments
		Over a period of time binaries used by your organization grows 
			(whether built in-house or downloaded
			With CI managing those binaries across 
				development, 
				QA, 
				staging,
				integration,
				early bird,
				production 
					can become a maintenance nightmare. 
		No need to duplicatefile. 
		Artifactory manages access to the file through repositories. 
		Repositories behave like virtual file systems 
			can be dedicated to development groups and their respective environments. 
		Access by teams and build server is controlled by 
			defining corresponding repositories 
				configuring access control on the binary 
					as it goes through the development lifecycle. 
		Consider the matrix of 
			binaries, 
			development groups 
			environments in your system 
			- that explains the need for a repository manager
	
	3. Security, Access Control and Traceability
		Virtual repository 
			Encapsulates any number of 
				local and 
				remote repositories
			Represents them as a unified repository accessed from a single URL. 
			Provides a way to manage 
				which repositories are accessed 
				by developers 
				
				freedom to mix, match and modify the actual repositories included within it. 
			Optimize artifact resolution 
				by defining the underlying repository order 
					order: 
						local repositories, 
						then remote repository caches, 
						then over network remote resource. 
			Developer: 
				Request the package
				Artifactory will safely and optimally access it 
					according to your organization’s policies.

		Outside artifactory 
			Security policies can be setup to restrict/allow access internal resources 
		How to control what people can download from external resources? 
		Artifactory 
			provide security and access control at several levels. 
				From restricting complete repositories to restricting a single binary
				From a group of any size down to a single developer.

		Virtual repositories 
			restrict developer access only to reliable 3rd party resources 
				that have been approved.

		“Excludes” and “Includes” 
			let you use naming patterns 
			define anything from a whole repository that should be excluded 
				from your organization’s access, 
				to including a single artifact

		Permission targets and permissions can be defined 
			to configure user or group access privileges 
				to different resources that have been downloaded.

		Integration with 
			LDAP, 
			SAML, 
			Crowd 
				and others manages access to your servers.

		Comprehensive log information 
			lets you trace virtually any action done 
				on any artifact managed by Artifactory.


	4. Full Support for Docker
		Artifactory 
			fully-fledged Docker repository 
			support all Docker Registry APIs. 
			Docker client can work with Artifactory directly
				presenting several benefits for enterprise Docker users.

			Mirantis(Docker) - JFrog (artifactory) partnership

		Using local repositories
			distribute and share images within your organization 
			manage images between different teams easily. 
			Can replicate Artifactory Docker repositories 
				to remote instances of Artifactory 
			share images with colleagues in geographically distant sites.

		Fine-grained access control to your organization’s images 
			secure “docker push” and “docker pull” 
			Thus provide secure, private Docker repositories 
				that exceed the security offered by Docker Trusted Registry.

		Using Artifactory,[Not private repositories on Docker Hub], 
			removes issues related to internet connectivity 
			resulting in reliable and consistent access to images. 
			Run in High Availability configuration 
				provide system stability and availability of 
					your Docker images that is unmatched in the industry.

		Artifactory’s smart search makes it easy to find any Docker image 
		Full support for the Docker Registry API supports 
			basic search with the Docker client
			Built in searches answer common needs with single-click operations, custom properties provide the flexibility to meet a variety of specific needs, and Artifactory Query Language offers a simple way to formulate complex queries letting you find images based on any set of criteria.
		Whether you’re already on board with Docker or just evaluating how to introduce it to your organization, once you’re using Artifactory to manage your packages, you’re already covered for Docker images.

	5. Quickly replicate repositories to remote sites
		CHECKSUM-BASED STORAGE
		Artifactory optimizes storage by ensuring that any binary is only stored once on the file system. When a binary is uploaded to a local repository, or downloaded to a remote repository, rather than storing the file in its original name under a specific path, Artifactory creates a checksum (both MD5 and SHA1 are supported) of the file and renames the file to its checksum. All the metadata about a file is then stored in the Artifactory database. Therefore, to create a copy of a file in a different location, there is no need to actually copy the file, only the metadata is copied and this maintains a reference to the same physical file.

		Using traditional file-system storage, replicating a repository means that if the same file is stored in several different places, it needs to be synched over to the remote site several times. As the number of binaries you need to manage grows to accommodate different stages in the build automation flow (Dev, QA, Production) and different customers (both internal and external), the amount of data you need to replicate to remote sites can multiply very quickly, and can consume huge amounts of network resources taking a considerable amount of time.

		Artifactory supports replication of your repositories to another instance of Artifactory which is outside of your local network. Replicated repositories are automatically synchronized with their source periodically, so that your artifacts can be made available to different teams wherever they may be located around the world. Artifactory’s checksum-based storage optimizes the replication process making it up to 10 times faster. Since any artifact is stored within a repository only once, and “copies” are actually metadata references to the same physical file, the amount of data that needs to be copied to the remote site when replicating a repository is dramatically reduced. The actual binary file only needs to be copied over once. Any additional “copies” represented by metadata, are much smaller than the file itself. As an added benefit, the metadata contains extensive log information regarding the physical file to which it refers. This means that any file within the replicated repository is copied over with full traceability. All relevant log information is stored in the metadata which is actually copied over.

	6. Full support for CHEF to manage infrastructure
		Part of your role as DevOps is to manage different infrastructure configurations depending on the environment – development, QA or production. Each environment may have different yet overlapping requirements for setup, and you need to be able to manage all the packages that should be installed easily and efficiently.

		Artifactory can make configuration a quick and painless process. You can define specific repositories per environment and direct your CHEF configuration script to the right repository in Artifactory. This ensures that each server you configure will only get the packages approved for the designated environment. And if there are overlapping requirements between the different environments, there is no need to maintain multiple copies of any package. Artifactory manages that for you with internal references.

	7. Advanced package management with “watches” and user plugins
		USER PLUGINS
		User Plugins give you a way to extend the functionality of Artifactory with any custom behavior required by your organization. To keep things simple, they are written as Groovy scripts and have a simple DSL to wrap them as closures within the extension points. The plugins can be changed and redeployed on-the-fly, and can even be debugged – all from within your favorite IDE.

		While organizations may share common best practices in how they manage their packages, each organization is different and may have some unique requirements.

		In Artifactory you can define “watches” which let you closely monitor any of the critical packages in your system. In case a package is accidentally deleted or moved, you can receive an immediate alert to restore it as required. But Artifactory also provides much more flexible and advanced package management capabilities.

		Artifactory generates an event for virtually every action performed on a package including download, deployment, moving, copying and more. For every such event you may write a user plugin that effectively extends the Artifactory REST API giving you a simple way to add functionality to Artifactory, and implement complex, custom behavior in your binary management workflow. This includes scheduling tasks, managing security and authentication, license compliance and opensource governance, artifact resolution and deployment, build integration and promotion logic, maintenance and cleanup and more.

	8. A Universal, End-to-End Solution For All Binaries
		No single tool or technology is enough to support development in a modern organization. There is a multitude of packaging formats, a variety of build tools, different continuous integration systems and other technologies that go into building a flexible and maintainable software development ecosystem. Managing binaries for all the different packaging formats and integrating with all the moving parts of the ecosystem can become a maintenance nightmare.

		Artifactory was designed from the ground up to fit in with any development ecosystem. Uniquely built on checksum-based storage, Artifactory supports any repository layout and can, therefore, provide native-level support for any packaging format. Essentially, regardless of the packaging format you are using, Artifactory can store and manage your binaries, and is transparent to the corresponding packaging client. The client works with Artifactory in exactly the same way it would work with its native repository. For example, if you are working with Docker, Artifactory proxies Docker Hub (or any other public Docker registry), lets you store and manage your own images in local Docker repositories, and works transparently with the Docker client. If you are working with node.js, Artifactory proxies npmjs.org (or any other public npm repository), lets you store your own packages in local Npm repositories, and works transparently with the npm client. Similarly for Vagrant, NuGet, Ruby, Debian, YUM, Bower, Python and more.

		But development is only one end of the software delivery pipeline. Before a package makes it into a product, it needs to go through processes of build and integration. There are many build and integration tools on the market, but there is only one product that works with them all. Through a set of plugins, Artifactory provides tight integration with popular CI systems available today such as Jenkins, Bamboo and TeamCity. These systems use Artifactory to supply artifacts and resolve dependencies when creating a build, and also as a target to deploy build output. And to support cloud-based CI systems on which you are not able to apply plugins, Artifactory provides plugins for the build tools you use (such as Maven and Gradle) which ultimately provides the same level of build automation. That takes care of development and deployment, but what about distributing your software once it’s ready for consumption. That’s where Bintray comes in.

		Bintray is JFrog’s download center in the cloud offering rapid downloads, fine-grained access control, detailed stats and logs and an extensive REST API. Promoting releases for distribution from Artifactory is a matter of a single-click or API call. Like Artifactory, Bintray is package-agnostic and works seamlessly with all the different package clients, so it can be fully integrated into any continuous integration/continuous delivery ecosystem.
		Artifactory is a universal repository. It is the single tool that sits in the center of your development ecosystem and “talks” to all the different technologies, increasing productivity, reducing maintenance efforts and promoting automated integration between the different parts. Together, Artifactory and Bintray are the central components of a fully-automated software distribution pipeline.

	9. Plugin and integrations 
		e.g. Docker integration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# System Requirements
https://www.jfrog.com/confluence/display/JFROG/System+Requirements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Installing Artifactory in Linux
https://www.jfrog.com/confluence/display/JFROG/Install
https://www.jfrog.com/confluence/display/JFROG/Installing+Artifactory
https://www.jfrog.com/confluence/display/RTF6X/Installing+on+Linux+Solaris+or+Mac+OS

https://www.devopsschool.com/tutorial/artifactory/artifactory-install-and-configuration.html


	Developed in java
	Install java 
		Is platform independent.
		Can be installed on 
			windows
			linux
			mac
	Identify the flavour to install
		Artifactory OSS
			Free: 
			Only for 
				Open source
				Colleges
				Universities
		Artifactory Pro
			Paid. 
			Can be installed on prim
				Behind a firewall
		Artifactory Cloud
			SaaS solution
				
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Using Artifactory

https://www.jfrog.com/confluence/display/RTF5X/Using+Artifactory
	Getting started
		https://www.jfrog.com/confluence/display/RTF5X/Getting+Started
	
	
	Viewing Packages
	Using WebDAV
	Searching for Artifacts
	Deploying Artifacts
	Manipulating Artifacts
	Updating Your Profile
	Authentication
	
	
	Default
	-------
	Artifacts, Search etc are disabled.
	Click on Admin - disabled.
	
	credentials: admin/password
	
	No license found - 
	https://jfrog.com/artifactory/free-trial
	
	
	Type of repo. we can create
	
		Local
			Store project artifacts
		Remote
			
		Virtual
		Distribution Repositories
		Layouts
		
		

Why can't we use git or any other scm for storing artifacts.
	SCM : Source code management
	What is the diff. between sources and binaries
	
	Sources				Binaries
Text					Blobs/binaries
Diffable				Non-diffable
Versioned by content	Versioned by name.
Stored by override		Not stored by override.
      

What is JFrog Artifactory
	1. Store artifacts and dependencies
		send updated artifacts for deployment.
	2. Download and manage dependencies.
	3. Universal binary repository manager
	4. Proxy for remote repositories
	5. Dependency managers will work with JFrog Artifactory.
	6. CI servers would work with JFrog Artifactory.
	7. Single source of truth for binaries

		
		
Why JFrog for devops.
	1. HA
		system stability and reliability
	2. Managing binaries across diff. environments.
	3. Security, access control and traceability
	
	4. Full support for docker
	5. Quickly replicating remote repos in local area
	6. Support for chef
		Create targetted confi
	
	
	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Getting Started
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# General Information

There are various solutions which come under the umbrella of Jfrog.
Following are the list of such Jfrog solutions
	JFrog Platform
		JFrog Artifactory
		JFrog Artifactory Edge
		JFrog Xray
		JFrog Distribution
		JFrog Mission Control
		JFrog Pipelines
	JFrog Cloud
	JFrog Self-Hosted
	JFrog Partner Integration

Details of the solution
-----------------------
	JFrog Platform
		JFrog Artifactory
		JFrog Artifactory Edge
			Edition of JFrog Artifactory 
			Features customized to serve the primary purpose of distributing software to a runtime like 
				data center
				point-of-sale 
				mobile device. 
			Packages hosted in Edge node are 
				part of a Release Bundle which is 
					secure 
					immutable 	
						collection of software packages 
						
			More details: https://www.jfrog.com/confluence/display/JFROG/JFrog+Artifactory+Edge			
		JFrog Xray
			Universal software composition analysis (SCA) solution 
			Natively integrates with Artifactory
			Gives an easy way to proactively identify vulnerabilities 
				on open source and license compliance violations, 
				before they manifest in production releases.
			Main Features
			-------------
			Refer: https://www.jfrog.com/confluence/display/JFROG/JFrog+Xray for details
			Early Detection
			On-Prem, Cloud, Hybrid or Multi-Cloud Solution
			Deep Recursive Scanning
			Continuous Impact Analysis
			Native Integration with Artifactory
			Vulnerability Database
			Custom API-Driven Automation
			Universal Artifact Analysis

				
		JFrog Distribution
			Centralized secure and structured platform to 
				distribute release binaries to multiple remote locations 
				update new release versions. 
			Lets you provision software release distribution. 
			Core part of JFrog Enterprise+
			Manages Release Bundles and their distribution processes
				including release content, 
				permission levels
				target destinations.
			As part of the release flow, release bundles are 
				verified by the target destination to ensure they are 
					signed correctly 
					safe to use.
			Further details: https://www.jfrog.com/confluence/display/JFROG/JFrog+Distribution
		JFrog Mission Control
			Single access point for managing multiple JFrog Platform Deployments (JPDs). 
			View all JPDs under your administrative control 
				installed local/remote sites around the world. 
				See connections between them
				Perform operations on several instances at once
				Drill down to view and configure a single instance at a time.
			More details: https://www.jfrog.com/confluence/display/JFROG/JFrog+Mission+Control
		JFrog Pipelines
			Offers JFrog Platform customers three vital capabilities: 
				end-to-end automation (CI/CD), 
				workflow and tool orchestration
				optimization of the JFrog toolset. 
				
			Pipelines is enterprise-ready and universal.


			More details: https://www.jfrog.com/confluence/display/JFROG/JFrog+Pipelines
	JFrog Cloud
		If you do not yet have a subscription
			get started with a Free subscription of the JFrog Platform on the Cloud. 
	JFrog Self-Hosted
		
		The JFrog Platform represents a major architectural change that affects all JFrog products. These changes are not backward compatible with previous major versions. As such, new installations should use only the versions below and not mix them with previous major versions. Similarly, customers upgrading from the previous major versions will need to upgrade all products currently in use to the versions below.
		
		Kindly cross check the version below https://www.jfrog.com/confluence/display/JFROG/JFrog+Self-Hosted

			JFrog Artifactory 7.x
			JFrog Mission Control 4.x
			JFrog Xray 3.x
			JFrog Distribution 2.x
			JFrog Pipelines 1.x
		
	JFrog Partner Integration


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Artifactory Terminology

Artifactory Terminology and Navigation

	Artifactory provides you with the features you need to manage your binary repositories, both through an intuitive UI and with an extensive set of APIs.

	The Artifactory UI is divided into four main modules:Artifacts, Search, Build and Admin

	Home
	The Home module serves as a dashboard where you can easily access general information and commonly used features.

	Artifacts
	The Artifacts module is used to browse the repositories in your system and search for artifacts using a number of different methods. While browsing through repositories, Artifactory displays useful information and provides you with tools to perform essential actions to manage your repositories.

	Search
	The Search module is where you can search for Artifacts by name, package type, properties and a variety of additional methods offered by Artifactory. For more details, please refer to Searching for Artifacts.

	Build
	The Build module displays the Build Browser where you can view all the CI server projects that output their builds to Artifactory. Here you can drill down to view detailed build information and compare one build to another.

	Admin
	The Admin tab is only available to users who are defined as administrators in the system, and is used to perform a variety of administration and maintenance activities such as:

	Configuring different entities such as repositories, software licenses, proxies, mail servers and more
	Managing different aspects of system security such as user definitions, groups, permissions, LDAP integration and more
	Managing backup and indexing of repositories
	Managing import and export of repositories or of the entire system
	Accessing system information and scheduling different cleanup operations

	Set Me Up
	Artifactory's Set Me Up feature provides you with the commands you can use to deploy and resolve artifacts to and from specific repositories. Simply select any item in the Tree Browser or Simple Browser and click Set Me Up. Regardless of what was selected when you pop up this dialog, you can select a Tool and a specific Repository (the list of repositories displayed corresponds to the tool you selected), and Artifactory will provide the relevant commands according to your selection.

	Inserting User Credentials
	Every Set Me Up dialog includes an "Insert Credentials" button. When pressed, Artifactory will prompt you for your password and will then replace generic credential placeholders used in code snippets with your own corresponding credentials.

	Keyboard Shortcuts
	To facilitate easy navigation through its UI, Artifactory offers the following set of keyboard shortcuts:

	Ctrl/Cmd + Alt + B	Display the Build Browser in the Build module
	Ctrl/Cmd + Alt + R	Display the Artifact Repository Browser in the Artifacts module
	Ctrl/Cmd + Alt + N	Create a new item (where relevant). For example, when viewing the list of local repositories, Ctrl/Cmd + Alt + N will pop up a dialog to create a new one.
	Ctrl/Cmd + Alt + >	Open the Admin module menu. Once in the menu, you can browse through items using the up/down arrow keys or the tab key.
	Ctrl/Cmd + Alt + <	Close the Admin module menu.
	Repository Types in Artifactory
	Artifactory hosts three types of repository:

	Local
	Local repositories are physical, locally-managed repositories into which you can deploy artifacts. Artifacts in a local repository can be accessed directly using the following URL:
	http://<host>:<port>/artifactory/<local-repository-name>/<artifact-path>
	Artifactory is deployed with a number of pre-configured local repositories which can be used for internal and external releases, snapshots and plugins.

	Remote
	A remote repository serves as a caching proxy for a repository managed at a remote URL (which may itself be another Artifactory remote repository). Artifacts are stored and updated in remote repositories according to various configuration parameters that control the caching and proxying behavior. You can remove artifacts from a remote repository cache but you cannot actually deploy a new artifact into a remote repository.
	Artifacts in a remote repository can be accessed directly using the following URL:
	http://<host>:<port>/artifactory/<remote-repository-name>/<artifact-path>
	This URL will fetch a remote artifact to the cache if it has not yet been stored.

	Virtual
	A virtual repository (or "repository group") aggregates several repositories with the same package type under a common URL. The repository is virtual in that you can resolve and retrieve artifacts from it but you cannot deploy artifacts to it.

	Local and remote repositories are true physical repositories, while a virtual repository is actually an aggregation of them used to create controlled domains for search and resolution of artifacts.
	To configure repositories, in the Admin module, select Repositories.
	Repositories can be created, deleted, edited, ordered and aggregated.

	Single Package Type
	When creating any repository, you must specify its package type; this is a fundamental characteristic of the repository and can not be changed later. Once the repository type is set, Artifactory will index artifacts and calculate the corresponding metadata for every package uploaded which optimizes performance when resolving artifacts. Note that virtual repositories can only include repositories of the same type.

	Generic Repositories
	You may define a repository as Generic in which case it has no particular type, and you may upload packages of any type. Generic repositories do not maintain separate package indexes. For using a client associated with a specific package type (e.g. yum, gem) you should create a matching repository.

	General Resolution Order
	You can set the order in which repositories of each type (local, remote and virtual) are searched and resolved by simply ordering them accordingly within the corresponding section of the Configure Repositories page. To set the order you need to add the repositories to the list of selected repositories in the order in which they should be searched to resolve artifacts.
	The order in which repositories are searched is also affected by additional factors such as security privileges, include/exclude patterns and policies for handling snapshots and releases.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Artifactory Repository Types

https://jfrog.com/knowledge-base/what-are-different-types-of-repositories-that-artifactory-supports/

https://jfrog.com/whitepaper/best-practices-structuring-naming-artifactory-repositories/#:~:text=Artifactory%20hosts%20four%20repository%20types,search%20and%20resolution%20of%20artifacts.


Artifactory hosts four repository types: 
	Local, 
	Remote, 
	Virtual 
	Distribution. 
	
	
	Local and remote repositories are 
		true physical repositories
	Virtual repository 
		aggregation of them 
		used to create controlled domains 
			for search and resolution of artifacts. 
	Distribution repositories 
		special-case for exporting data from Artifactory to JFrog Bintray.
		
		JFrog Bintray 
			Universal distribution platform. 
			A cloud platform 
				gives you full control over how you 
					publish, 
					store, 
					promote, 
					distribute 	
						software.
			supports all file formats 
			offers advanced integration with common development technologies. 
			
	1. Local Repositories
	---------------------
	Using the below four-part naming structure we can address all required considerations for a local repository naming convention: 
		Team/Organization (business unit or product), 
		Technology, 
		Maturity, 
		Locator. 
		
		Order of these are imp.
		The JFrog recommendation: 
			<team>-<tech>-<maturity>-<locator>.

	Two basic use cases for local repositories: 
		The first use case 
			your own organization artifacts. 
		In this case, locator is purely based on topological considerations. 
		Team and maturity get a little more complex
		
		Team depends on 
			business logic 
			permissions. 
		Maturity 
			depends on the gates and artifact	
			ownership/disposition. If 
			
			Artifactory instance is focused on deployment
				Not generated, 
				merit in considering that maturity is actually more important than technology. However, conforming to a uniform naming convention takes precedence.

	Local Repositories
	-------------------
	Local repositories are 
		physical, 
		locally managed repositories 
			can deploy artifacts. 
	Typicallyused to deploy 
		internal and external releases 
		development builds
		Can be used to store binaries 
		not widely available on public repositories 
			3rd party commercial components. Using local repositories, all of your internal resources can be made available from a single access point across your organization from one common URL. Learn more >
	A critical second use case for local repositories 
		store third party artifacts. 
		This usually covers either a scenario where for whatever reason you can’t remote the source of the third party artifact (either because of an air-gap or just because it doesn’t have http access), or you’re implementing a white-list approach. In both of these cases, in general, technology remains the same, but the team name should be something that indicates its source location; for example, tomcat or centos. Because typically there is still a topology for these, locator also works the same as it is for other local repositories. Maturity, however, is now not something like release/dev, but instead reflects the trust level of the artifact. So it might be “upload” or “whitelist”. For example, “tomcat-mvn-upload-local”. If you are using local repositories to snapshot a remote in a state, this might be a date. For example,”centos7-rpm-oct2017-local”.



	2. Remote Repositories
Remote repositories fit into two categories:

Those that are part of an Artifactory topology, in which case their naming convention should align with that of local repositories and the four relevant parts, with the locator indicating the source repository being remoted.

Remote Repositories
A remote repository serves as a caching proxy for a repository managed at a remote site such as JCenter or Conan-Center. Artifacts are stored and updated in remote repositories according to various configuration parameters that control the caching and proxying behavior. Learn more >
Those that are central repositories. These are the external repositories your artifacts are being pulled from, and can be referred to by their source id, such as JCenter. For strict conformance, you could consider the following model, <central_name>-<technology>-remote, where the default Artifactory naming behavior uses the source. Generally, this helps to easily identify artifacts.

JCenter and Central Repositories
JCenter is a one-stop-shop for Maven artifacts in Bintray, JFrog’s software distribution platform. It is a large, popular, Maven repository that is managed by Bintray and is publicly available to all Bintray users to publish, download and share binaries with the developer community. Conan-Center is an additional central repository available on Bintray, for C/C++ Conan packages.
	
	
	
	
	
	
	
	
	
	3. Virtual Repositories
There are two types of virtual repository names.

Most virtual repositories do not contain a <locator>, and are made up of <team>-<tech>-<maturity>. In many cases, users do not need to know about topological implementation details. In general, its best practice that all consumption and writes are done through virtual repositories, as opposed to local/remote repositories. This is so that as many implementation details as possible can be omitted, letting the users work with a single, well-known URL. Additionally, while for local repositories maturity is strictly about artifact stages, for virtual repositories you may consider the audience more. For example, virtual repositories containing “-dev” in their name indicate the virtual repositories that the developers should be using. Finally, a common use case is for an entire company to use a virtual repository that aggregates all repositories of a specific technology, such as Docker, for both resolution and read permissions. While strict conformance with the naming convention would require the team name to be ‘all’ or something similar (e.g. all-mvn-release), it is more common to simply omit the team name and have repository name such as docker-stage.

The other major type of virtual repository name is aliasing for conformance, for example, with the requirements of an external tool or legacy automation. Virtual repositories allow you to make an alias of a single or multiple repositories. This may be a conformant name, but can also be highly useful if you need to accommodate a legacy build process or a particular tool to use a specific name. For example, for homebrew, it is useful to have a virtual repository called “bottles”. In general these names are not subject to conformance with a standard practice, although where possible try to avoid outright violations where a virtual repository seems to conform but does not. An example would be calling a virtual repository “ci-files-local” due to requirements of automation needing this repository name; this is distinctly not recommended if it can be avoided.

Virtual Repositories
A virtual repository encapsulates any number of local and remote repositories, and represents them as a unified repository accessed from a single URL. It gives you a way to manage which repositories are accessed by developers since you have the freedom to mix, match and modify the actual repositories included within the virtual repository. You can also optimize artifact resolution by defining the underlying repository order so that Artifactory will first look through local repositories, then remote repository caches, and only then Artifactory will go through the network and request the artifact directly from the remote resource. For the developer it’s simple. Just request the package, and Artifactory will safely and optimally access it according to your organization policies. Learn more >



4. Distribution Repositories
Distribution repositories are a bit of an outlier in this convention, because they can support multiple technology types, and generally don’t have multiple maturity levels, as you should only be distributing mature artifacts. In general they should end in “-dist” as the locator. Distribution repositories that distribute products should use the following convention: <productname>-product-<orgname>-dist. Distribution repositories that are more generic should have some name designator of the ruleset they’re configured for with a convention like <ruleset>-<orgname>-dist. Orgname can be omitted if your organization does not have multiple Bintray organizations, which is relatively common. However, it is mandatory to have different distribution repositories to distribute to different organizations, and additional organizations (for example to support open-source projects) are not unheard of either. A bit of forward planning doesn’t hurt anything, which is why its included in the recommended convention.

Distribution Repositories
Distribution repositories provide an easy way to move artifacts from Artifactory to Bintray, for distribution to end users. As opposed to other repositories in Artifactory, distribution repositories are not typed to a particular package format, but rather, are governed by a set of rules that specify how an artifact that gets to the distribution repository should be routed to its corresponding repository in Bintray. Learn more >









REPOSITORY ORGANIZATION AND MANAGEMENT
-------------------------------------

Now that we’ve established the basic repository naming structure, let’s review the different considerations you need to take when organizing your repositories in JFrog Artifactory. In essence, repository organization boils down to three things: security, performance and operability. And mostly, these considerations will determine what granularity you set “team” at, and to a lesser extent what granularity you calculate maturity levels.

1. Security
Artifactory permission targets allow for managing permissions via include/exclude patterns at an individual folder or even file level. In general, the best practice here is to manage permissions at the repository level. For repositories with highly structured organization, like Maven and RPM, it is possible to achieve a great deal of granularity at the folder level. However, this can still be too complex for administrators to keep track of (although effective permissions analysis can help). This is particularly true of READ permissions, although the finer granularity for those technologies where it works may be used for write permissions.

At a minimum, you should have separate repositories within the same technology and maturity level whenever you have teams that are not collaborating or sharing data, and thus do not have/need read permissions on each other’s software. You may also choose to provide different repositories based on write permissions, and assume they are aggregated in virtual repositories for read. This choice of write-based repositories is especially crucial in repository types which aren’t well divided by namespacing, such as the default NuGet behavior or an npm repository that isn’t scoped.

2. Performance
Another major concern is performance. This varies a bit by technology, but for any given technology there tends to be a maximum number of packages that make sense in that repository. In Maven this tends to be hundreds of thousands and driven more by UI considerations. Whereas in Yum/Debian this tends to be more in the tens of thousands, and driven more by the overall approach to calculating indexes and the size of the resulting index files, and their impact on client performance.

The other side of this are cleanup policies. An artifactory server with absolutely no cleanup policies in place will grow in storage usage very fast, and in general most of it will not be things you actually need to store. Mechanisms for implementing cleanup policies are a different discussion. Some can be found here. Based on the business requirements of the organization, different projects may have different policies. A primary driver for this tends to be maturity, discussed above. For example, a dev-sandbox docker registry may have a policy which states that any Docker tag which hasn’t been downloaded in the last two weeks should be deleted. On the other hand, a regulated industry may have a regulatory requirement that any object which has been in the regulated production environment must be retained for ten years. A solid promotion model between these stages of the lifecycle to different repositories is critical. But these policies are also probably not the same for all applications being developed. While an application for processing stock trades in production will fall under regulation, that same company’s tool for managing what to order for lunch can probably be discarded shortly after its “production” life cycle is complete, but does need to be maintained while it is actually being used.

3. Operability
When it gets to administering artifact repositories for specific teams in specific environments, other basic operability considerations apply. In general, these policies will want to be handled at the repository level, and so this will be a driving determination in choosing your repository structure.

The first is a fairly simple one: determining business value. If you are managing an Artifactory that spans multiple large projects and business units within the company, in addition to the considerations above, you will want to be able to determine how these different projects/units are using the Artifactory service. This may be for explicit chargebacks, or merely to track what units are resulting in what sorts of costs. As soon as you want to track usage for a given unit of organization in the company separately from other organizations, it should have its own repositories, and be broken down in the naming conventions accordingly for ease of identification.

Additionally, at a minimum, you must have separate repositories once you go beyond the bounds where the business can successfully coordinate naming conventions and directory structure organizations. That is to say if a team is too large to successfully manage something like group ids/naming conventions for artifacts without a horribly bureaucratic process, it is better to just give them separate repositories, and there is always a scale where this limitation exists. In general write permissions, and even more so delete permissions, should be reasonably specific to prevent teams from interfering with each other’s work. Delete permissions in general should only be provided to a very small group, outside of policy-based reapers (see the discussion on cleanup policies in the performance section above).

Taking all this into consideration, typically administrators prefer fewer repositories. Even though the more heavily automated your repository management process is, the less it really matters. For example, in a strong DevOps environment you could end up in a situation where every single test could be viewed as a promotion. While it might make sense to use the promotion API for each test, it probably does not make sense to have a repository for each one of dozens of tests, but rather to track this via properties, and reserve separate repositories for major control points

	
	
	
	RECOMMENDED CONVENTIONS
The following tables summarize the best practice naming convention with examples for each repository type.

1. Local Repositories
team-tech-maturity-locator

Examples:

tigerteam-docker-dev-local
tigerteam-docker-release-local
Name Part	Recommendation
<team>	
	This is the hardest part of the naming convention. It is based on the granularity you want to manage permissions/performance/operability concerns.
	It may also be a product name, or refer to a source for third party libraries.

<tech>	
	The content type. This is typically the package type, such as: mvn, rpm, docker.
	It may also be more specific, such as centos or ubuntu.

<maturity>	
	The maturity level within a process, either the SDLC process or a whitelisting/approval process for third party artifacts.
	For example, a series such as:
	Scratch (For developers sharing from their systems e.g. docker)
	Dev (For CI builds)
	QA (Promoted builds)
	Preprod (Promoted builds)
	Prod (Promoted builds for use)
	Archive (Builds retained for regulatory purposes)
	For third party libraries it might be values such as:
	Upload
	Whitelist
	Jan2018 (typically used when snapshotting a remote repository)
<locator>	
	Based on the physical location/artifactory service ID. The default is ‘local’ for a repository that is actually written to, but in case of multi-push replication it may be the site of the source of pushed events.
	In general you should not write to a repository that doesn’t have the ‘local’ designator except through replication.
	
	
	
	
2. Remote Repositories
Examples:

tiger-mvn-release-boston
jcenter-remote
Repository Use Case	Recommendation
Part of an Artifactory topology	For remoting another artifactory server, go with the same naming convention as local repositories, based on the repository it is remoting.  
<locator> in this case should be the identifier of the remote artifactory.
Central Repository	<centralname>-remote
“-remote” is optional, but helpful to avoid confusion with virtual repository naming conventions.

i.e. jcenter-remote or just ‘jcenter’





3. Virtual Repositories
<team>-<tech>-<maturity>

Examples:

tiger-docker-dev
tiger-docker-prod
Name Part	Recommendation
<team>	A group that shares read permissions.
If you are using virtual write to control writes, then you may control this at the write permission level.

<tech>	The package type.
<maturity>	This part may be omitted. However, it is often used as part of the write-control feature and/or specifically for production.
Unlike <maturity> in local repositories, it is much more likely to be controlled from a deployment model perspective than a CI perspective.





4. Distribution Repositories
Examples:

artifactorypro-product-jfrog-dist
examples-jfrogtraining-dist
Repository Use Case	Recommendation
Distribution names with a product	<productname>-product-<orgname>-dist
<productname> is the name of the product in bintray

Other distribution repositories	<rule designator>-<orgname>-dist
<rule designator> is a selector for a unique rule set indicating which teams/products should use it for distribution repositories not associated with a product

<orgname>	Designates the bintray organization being distributed to.  If you are certain you will only ever have one (which is not uncommon) it can be omitted.	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Artifactory Authentication
https://www.jfrog.com/confluence/display/RTF5X/Authentication

Authentication supported in Artifactory.



Basic Authentication
	Flexible permission-based system to 
		control users' access to 
		different features and artifacts.




LDAP
	Authenticate users based on LDAP server out-of-the-box. 
	When LDAP authentication is active, 
		Artifactory first attempts to authenticate the user against the LDAP server. 
	If LDAP authentication fails, 
		Artifactory tries to authenticate via its internal database. 
	For every LDAP authenticated user 
		Artifactory creates a new user in the internal database (provided that the user does not already exist), and automatically assigns that user to the default groups.

To learn more, please refer to Managing Security with LDAP.



Active Directory
Artifactory supports integration with an Active Directory server to authenticate users and synchronize groups. When authentication using Active Directory is configured and active, Artifactory first attempts to authenticate the user against the Active Directory server. If the authentication fails, Artifactory tries to authenticate via its internal database. For every externally authenticated user configured in your Active Directory server, Artifactory creates a new user in the internal database (provided the user does not already exist), and automatically assigns that user to the default groups.

To learn more, please refer to Managing Security with Active Directory.




Single Sign-On
The Single Sign-on (SSO) Add-on allows you to reuse existing HTTP-based SSO infrastructures with Artifactory, such as the SSO modules offered by Apache HTTPd. Artifactory's authentication will work with commonly available SSO solutions, such as native NTLM, Kerberos, etc... SSO works by letting Artifactory know what trusted information it should look for in the HTTP request, assuming that this request has already been authenticated by the SSO infrastructure, which sits in front of Artifactory.

To learn more, please refer to Single Sign-on.





SAML
SAML is an XML standard that allows you to exchange user authentication and authorization information between web domains. JFrog’s Artifactory offers a SAML-based Single Sign-On service allowing federated Artifactory partners (identity providers) full control over the authorization process. Using SAML, Artifactory acts as service provider which receives users authentication information from external identity providers. In such case Artifactory is no longer responsible to authenticate the user although it still has to redirect the login request to the identity provider and verify the integrity of the identity provider’s response.

To learn more, please refer to SAML SSO Integration.




SSH
Artifactory supports SSH authentication for Git LFS and the JFrog CLI using RSA public and private keys. SSH has the benefit of two-way authentication. In other words, before any sensitive data is exchanged between Artifactory and the client, the Artifactory server is authenticated to the client, and then the user operating Git LFS or JFrog CLI client is authenticated to Artifactory. 

To learn more, please refer to  SSH Integration.



Atlassian Crowd Integration
The Atlassian Crowd Integration allows you to delegate authentication requests to Atlassian Crowd, use authenticated Crowd users and have Artifactory participate in a transparent SSO environment managed by Crowd. In addition, Atlassian Crowd Integration allows the use of JIRA User Server as an authentication server, but without support of SSO.

To learn more, please refer to Atlassian Crowd and JIRA Integration.



Access Tokens
Artifactory offers the option for authentication through access tokens. An access token may be assigned to a user, or to an entity that is not an Artifactory user such as a job in a CI server. Permissions are assigned to access tokens by including them in Groups. Access tokens offer advantages such as cross-site authentication, limited-time access, authenticated access for non-users and more. 

To learn more, please refer to Access Tokens. 





Custom Authentication with User Plugins 
You can use User Plugins to implement custom authentication policies.

To learn more, please refer to Management of Security Realms.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Deploying Artifacts using Maven
https://www.devopsschool.com/tutorial/artifactory/upload-artifacts-using-maven-in-artiactory.html
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Download Artifacts using Maven
https://www.jfrog.com/confluence/display/JFROG/Maven+Repository
https://stackoverflow.com/questions/51930841/download-artifacts-from-artifactory-using-maven
https://www.jfrog.com/confluence/display/JFROG/Maven+Artifactory+Plugin
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Browsing Artifactory
https://www.jfrog.com/confluence/display/RTF5X/Browsing+Artifactory	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Viewing Packages
https://www.jfrog.com/confluence/display/RTF5X/Viewing+Packages
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Searching for Artifacts
https://www.jfrog.com/confluence/display/RTF5X/Searching+for+Artifacts
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Manipulating Artifacts
https://www.jfrog.com/confluence/display/RTF5X/Manipulating+Artifacts
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

